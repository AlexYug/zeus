//SPDX-License-Identifier: UNLICENSED
pragma solidity >0.6.0;

abstract contract link {

  struct Message {
    bytes message; // message as bytes, must deserialize
    uint256 block_num;
  }

  struct Receipt {
    bytes message;
    bytes response;
    bool success;
    uint256 block_num;
  }

  address owner;

  uint64 current_local_message_id;
  uint64 current_foreign_message_id;
  uint64 current_foreign_receipt_id;
  uint64 current_local_receipt_id;

  uint256 last_received_foreign_message_block_num;
  uint256 last_received_local_message_block_num;
  uint256 last_received_foreign_receipt_block_num;
  uint256 last_received_local_receipt_block_num;

  uint8 required_sigs;

  // mapping/linked list of received messages
  mapping (uint64 => Message) public foreign_messages;

  // mapping/linked list of local messages
  mapping (uint64 => Message) public local_messages;

  // mapping/linked list of foreign receipts generated by processing
  // messages on foreign chain
  mapping (uint64 => Receipt) public foreign_receipts;

  // mapping/linked list of local receipts generated by processing messages
  mapping (uint64 => Receipt) public local_receipts;

  // mapping of bridge owners
  mapping (address => bool) public isOwner;

  mapping (uint256 => uint8) public numOfConfirmed;
  mapping (uint256 => bool) public executed;
  mapping (address => uint256) public hasConfirmed;

  constructor(address[] memory _owners, uint8 _required) {
    for (uint i = 0; i < _owners.length; i++) {
      require(!isOwner[_owners[i]] && _owners[i] != address(0));
      isOwner[_owners[i]] = true;
    }
    require(_required <= _owners.length);
    required_sigs = _required;
  }

  /**
    * @dev confirms consensus before execution
    *
    * @param id id
    */
  function confirmConsensus(uint256 id) public returns (bool) {
    require(!(hasConfirmed[msg.sender] == id), "sender already confirmed");
    require(isOwner[msg.sender], "sender not authorized");
    hasConfirmed[msg.sender] = id;
    numOfConfirmed[id] += 1;
    if (numOfConfirmed[id] >= required_sigs && !executed[id]) {
      executed[id] = true;
      return true;
    }
    return false;
  }

  /**
    * @dev view function which returns Messages only if 12 blocks have passed
    *
    * @param message_id the message to push
    */
  function getLocalMessage(uint64 message_id) public view returns (bytes memory message, uint256 block_num) {
    Message memory requestedMessage = local_messages[message_id];
    if (requestedMessage.block_num > 0 && block.number > (requestedMessage.block_num + uint256(12))) {
      return (requestedMessage.message, requestedMessage.block_num);
    }
    bytes memory emptyMessage;
    return (emptyMessage, 0);
  }

  /**
    * @dev view function which returns Messages only if 12 blocks have passed
    *
    * @param receipt_id the receipt id
    */
  function getLocalReceipt(uint64 receipt_id) public view returns (bytes memory message, bytes memory response, bool success, uint256 block_num) {
    Receipt memory requestedReceipt = local_receipts[receipt_id];
    if (requestedReceipt.block_num > 0 && block.number > (requestedReceipt.block_num + uint256(12))) {
      return (requestedReceipt.message, requestedReceipt.response, requestedReceipt.success, requestedReceipt.block_num);
    }
    bytes memory emptyMessage;
    return (emptyMessage, emptyMessage, false, 0);
  }

  /**
    * @dev handling the pushing of messages from other chains
    *
    * @param _message the message to push
    */
  function pushForeignMessage(bytes memory _message, uint256 id) public {
    if (!confirmConsensus(id)) {
      return;
    }
    Message memory message = Message(_message, block.number);
    foreign_messages[current_foreign_message_id] = message;
    current_foreign_message_id++;
    onMessage(_message);
  }

  /**
    * @dev handling the pushing of local messages
    *
    * @param _message the message to push
    */
  function pushLocalMessage(bytes memory _message) internal {
    Message memory message = Message(_message, block.number);
    local_messages[current_local_message_id] = message;
    current_local_message_id++;
  }

  /**
    * @dev handling the pushing of receipts from other chains
    * these receipts were generated from messages posted via this contract
    *
    * @param _message message
    * @param _response response
    * @param _success success
    */
  function pushForeignReceipt(
    bytes memory _message,
    bytes memory _response,
    bool _success,
    uint256 id
  ) public {
    if (!confirmConsensus(id << 32)) {
      return;
    }
    Receipt memory receipt = Receipt(_message, _response, _success, block.number);
    foreign_receipts[current_foreign_receipt_id] = receipt;
    current_foreign_receipt_id++;
    onReceipt(_message, _response, _success);
  }

  /**
    * @dev handling the pushing of local receipts
    *
    * @param _message message
    * @param _response response
    * @param _success success
    */
  function pushLocalReceipt(
    bytes memory _message,
    bytes memory _response,
    bool _success
  ) internal {
    Receipt memory receipt = Receipt(_message, _response, _success, block.number);
    local_receipts[current_local_receipt_id] = receipt;
    current_local_receipt_id++;
  }

  /**
    * @dev on message hook, unique implementation per consumer
    *
    * @param _message message
    */
  function onMessage(bytes memory _message) internal virtual;

  /**
    * @dev on receipt hook, unique implementation per consumer
    *
    * @param _message message
    * @param _response response
    * @param _success success
    */
  function onReceipt(
    bytes memory _message,
    bytes memory _response,
    bool _success
  ) internal virtual;
}
